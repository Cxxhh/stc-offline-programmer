# STC烧录工具移植分析文档

## 目录
1. [概述](#概述)
2. [烧录流程详解](#烧录流程详解)
3. [通信协议基础](#通信协议基础)
4. [不同STC型号的协议差异](#不同stc型号的协议差异)
5. [关键实现细节](#关键实现细节)
6. [移植到STM32的注意事项](#移植到stm32的注意事项)

---

## 概述

本文档基于stcgal（Python实现的STC MCU ISP烧录工具）源码分析，详细说明了STC系列MCU的烧录流程和不同型号之间的协议差异，为将烧录工具移植到STM32平台提供技术参考。

### STC烧录工具特点

- **通信方式**：UART串口或USB（部分型号）
- **协议类型**：基于数据包的ISP（In-System Programming）协议
- **支持型号**：STC 89/90/10/11/12/15/8/32系列
- **主要功能**：Flash编程、IAP/EEPROM编程、选项字节配置、频率校准

---

## 烧录流程详解

### 1. 整体流程图

```
┌─────────────────┐
│  1. 连接MCU      │ ← 打开串口/USB，设置初始波特率
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  2. 握手同步     │ ← 发送同步字符(0x7F)，等待MCU响应
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  3. 读取状态包   │ ← 获取MCU信息（型号、频率、BSL版本等）
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  4. 识别MCU型号  │ ← 根据Magic值查找型号数据库
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  5. 初始化选项   │ ← 解析并显示当前选项配置
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  6. 波特率切换   │ ← 从握手波特率切换到传输波特率
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  7. 擦除Flash    │ ← 发送擦除命令，等待完成
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  8. 编程Flash    │ ← 分块写入数据（128/64字节块）
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  9. 设置选项字节  │ ← 写入配置选项
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 10. 断开连接     │ ← 发送断开命令，关闭串口
└─────────────────┘
```

### 2. 详细步骤说明

#### 步骤1：连接MCU

**功能**：建立与MCU的物理连接

**实现要点**：
- 打开串口/USB设备
- 设置初始握手波特率（默认2400 bps）
- 配置串口参数（数据位8，停止位1，校验位根据协议类型）
- 清空输入缓冲区

**代码位置**：`protocols.py` - `StcBaseProtocol.connect()`

```python
# 关键代码示例
self.ser = serial.Serial(port=self.port, parity=self.PARITY)
self.ser.baudrate = self.baud_handshake  # 默认2400
self.ser.timeout = 0.5
self.ser.flushInput()  # 清空缓冲区
```

#### 步骤2：握手同步

**功能**：与MCU建立通信同步

**实现要点**：
- 发送同步字符（通常为0x7F）
- 循环发送直到收到MCU响应
- 支持自动复位（DTR/RTS控制）或手动复位

**关键代码**：
```python
def pulse(self, character=b"\x7f", timeout=0):
    """发送同步字符"""
    while True:
        self.ser.write(character)
        self.ser.flush()
        time.sleep(0.030)
        if self.ser.inWaiting() > 0:
            break
```

#### 步骤3：读取状态包

**功能**：获取MCU的基本信息

**数据包格式**（基础格式）：
```
[0x46, 0xB9]  # 帧起始标志
[0x68]        # 方向标志（MCU->Host）
[长度高字节, 长度低字节]  # 数据长度（大端序）
[状态数据...]  # 状态信息
[校验和]       # 校验和（根据协议不同）
[0x16]        # 帧结束标志
```

**状态包包含信息**：
- MCU Magic值（型号识别码）
- 时钟频率计数器
- BSL版本号
- 选项字节
- 校准数据（STC15+）

#### 步骤4：识别MCU型号

**功能**：根据Magic值确定MCU型号和协议类型

**实现方式**：
- 从状态包中提取Magic值（通常位于偏移20-21字节）
- 在型号数据库中查找匹配的型号
- 根据型号名称匹配协议类型

**协议自动检测**：
```python
protocol_database = [
    ("stc89", r"STC(89|90)(C|LE)\d"),
    ("stc12a", r"STC12(C|LE)\d052"),
    ("stc12b", r"STC12(C|LE)(52|56)"),
    ("stc12", r"(STC|IAP)(10|11|12)\D"),
    ("stc15a", r"(STC|IAP)15[FL][012]0\d(E|EA|)$"),
    ("stc15", r"(STC|IAP|IRC)15\D"),
    ("stc8g", r"STC8H1K\d\d$"),
    ("stc8d", r"STC8H"),
    ("stc8", r"STC8\D")
]
```

#### 步骤5：初始化选项

**功能**：解析并显示当前MCU的配置选项

**选项类型**（不同型号有差异）：
- 复位引脚使能
- 看门狗配置
- 低电压复位
- EEPROM擦除使能
- BSL引脚检测
- 时钟源选择
- 频率校准值（STC15+）

#### 步骤6：波特率切换

**功能**：从低波特率切换到高波特率进行数据传输

**切换流程**（以STC89为例）：
1. **测试新波特率**：发送0x8F命令，包含BRT寄存器值
2. **切换到新波特率**：发送0x8E命令
3. **Ping-Pong测试**：发送0x80命令，验证通信正常

**BRT计算**：
```python
# STC89系列
sample_rate = 16 if cpu_6t else 32
brt = 65536 - round(mcu_clock_hz / (baud_transfer * sample_rate))
```

**STC15+系列**：
- 需要先进行频率校准
- 使用固定的编程频率（22.1184 MHz）
- 校准过程较复杂，需要多轮挑战-响应

#### 步骤7：擦除Flash

**功能**：擦除Flash存储器

**擦除命令格式**（不同型号有差异）：
- **STC89**：`0x84` + 块数 + 填充数据
- **STC12**：`0x84` + 擦除参数 + 倒计时序列
- **STC15**：`0x03` + 擦除类型（Flash/Flash+EEPROM）

**块大小**：通常以512字节为单位

#### 步骤8：编程Flash

**功能**：将数据写入Flash存储器

**编程方式**：
- 分块写入（块大小：STC89/12为128字节，STC15为64字节）
- 每块写入后等待MCU确认
- 支持进度显示

**写入命令格式**：
```
[命令字节]  # 0x22（首块）或0x02（后续块）
[地址高字节, 地址低字节]  # 写入地址
[数据...]  # 块数据
```

**STC15+特殊处理**：
- 首块使用0x22命令
- 需要5A A5魔术字（BSL 7.2+）
- 写入完成后需要发送完成命令（0x07）

#### 步骤9：设置选项字节

**功能**：写入配置选项到Flash

**选项字节格式**：不同型号的选项字节长度和格式不同
- **STC89**：1字节（MSR寄存器）
- **STC12**：4字节
- **STC15A**：13字节
- **STC15**：5字节（部分型号）
- **STC8**：5字节

#### 步骤10：断开连接

**功能**：结束烧录会话

**实现**：
- 发送断开命令（通常为0x82或0xFF）
- 关闭串口/USB连接

---

## 通信协议基础

### 数据包格式

#### 通用数据包结构

```
┌─────────────┬──────────┬──────────┬──────────┬──────────┬──────────┐
│ 帧起始      │ 方向标志  │ 长度     │ 数据载荷  │ 校验和    │ 帧结束   │
│ 0x46 0xB9   │ 0x6A/0x68│ 2字节    │ N字节     │ 1-2字节   │ 0x16     │
└─────────────┴──────────┴──────────┴──────────┴──────────┴──────────┘
```

**方向标志**：
- `0x6A`：Host -> MCU
- `0x68`：MCU -> Host

**校验和计算**（不同型号有差异）：
- **STC89**：单字节校验和，`sum(packet[2:-2]) & 0xff`
- **STC89A**：双字节校验和，`sum(packet[2:-3]) & 0xffff`
- **STC12+**：双字节校验和，`sum(packet[2:-3]) & 0xffff`

### 关键命令码

| 命令 | 功能 | 说明 |
|------|------|------|
| 0x00 | 状态包 | MCU返回的状态信息 |
| 0x02 | 写入数据块 | 编程Flash数据块 |
| 0x03 | 擦除Flash | 擦除Flash存储器 |
| 0x04 | 设置选项 | 写入选项字节 |
| 0x05 | 测试/准备 | 测试通信或准备操作 |
| 0x07 | 完成写入 | STC15+写入完成确认 |
| 0x22 | 首块写入 | STC15+首块写入命令 |
| 0x50 | 握手请求 | STC12+握手请求 |
| 0x65 | 频率校准 | STC15A频率校准 |
| 0x69 | 完成写入 | STC12写入完成 |
| 0x80 | Ping-Pong | 通信测试 |
| 0x82 | 断开连接 | 结束会话 |
| 0x84 | 擦除确认 | 擦除操作确认 |
| 0x8D | 设置选项 | STC89设置选项 |
| 0x8E | 切换波特率 | 切换到传输波特率 |
| 0x8F | 测试波特率 | 测试新波特率设置 |
| 0xFF | 断开连接 | STC89A断开连接 |

---

## 不同STC型号的协议差异

### 1. STC89/90系列

**协议类**：`Stc89Protocol`, `Stc89AProtocol`

**特点**：
- 最简单的协议
- 无校验位（PARITY_NONE）
- 单字节或双字节校验和
- 块大小：128字节

**主要差异**：

| 特性 | STC89 | STC89A |
|------|-------|--------|
| 校验和 | 单字节 | 双字节 |
| 状态包起始 | 0x00 | 0x50 |
| 握手命令 | 0x8F/0x8E | 0x01 |
| 擦除命令 | 0x84 | 0x03 |
| 写入命令 | 0x02 | 0x22/0x02 |
| 选项命令 | 0x8D | 0x04 |
| 断开命令 | 0x82 | 0xFF |

**波特率计算**：
```python
# STC89
sample_rate = 16 if cpu_6t else 32
brt = 65536 - round(mcu_clock_hz / (baud_transfer * sample_rate))

# STC89A
sample_rate = 32
brt = 65536 - round(mcu_clock_hz / (baud_transfer * sample_rate))
```

**频率计算**：
```python
# STC89
freq_counter = average(8次频率计数)
mcu_clock_hz = (baud_handshake * freq_counter * cpu_t) / 7.0

# STC89A
freq_counter = status_packet[13:15]
mcu_clock_hz = 12 * freq_counter * baud_handshake
```

### 2. STC12系列

**协议类**：`Stc12AProtocol`, `Stc12BProtocol`, `Stc12Protocol`

**特点**：
- 引入偶校验（PARITY_EVEN）
- 双字节校验和
- 支持UID读取
- 块大小：128字节

**主要差异**：

| 特性 | STC12A | STC12B | STC12 |
|------|--------|--------|-------|
| 选项字节长度 | 4字节 | 4字节 | 4字节 |
| 选项命令响应 | 0x80 | 0x80 | 0x50 |
| 擦除倒计时 | 0x0D | 0x0D | 0x0D |
| 选项包格式 | 复杂 | 复杂 | 简单 |

**波特率计算**：
```python
brt = 256 - round(mcu_clock_hz / (baud_transfer * 16))
brt_csum = (2 * (256 - brt)) & 0xff
```

**频率计算**：
```python
freq_counter = average(8次频率计数)
mcu_clock_hz = (baud_handshake * freq_counter * 12.0) / 7.0
```

**IAP等待状态**：
```python
iap_wait = 0x80
if clock_hz < 1E6: iap_wait = 0x87
elif clock_hz < 2E6: iap_wait = 0x86
elif clock_hz < 3E6: iap_wait = 0x85
elif clock_hz < 6E6: iap_wait = 0x84
elif clock_hz < 12E6: iap_wait = 0x83
elif clock_hz < 20E6: iap_wait = 0x82
elif clock_hz < 24E6: iap_wait = 0x81
```

### 3. STC15系列

**协议类**：`Stc15AProtocol`, `Stc15Protocol`, `StcUsb15Protocol`

**特点**：
- 需要频率校准（RC振荡器）
- 使用固定编程频率（22.1184 MHz）
- 块大小：64字节（UART）或128字节（USB）
- 支持外部时钟源
- 选项字节更复杂

**频率校准流程**（STC15A）：

1. **第一轮校准**：
   - 发送0x65命令，包含校准数据和频率挑战序列
   - MCU返回频率计数响应
   - 根据响应选择合适的分频范围

2. **第二轮校准**：
   - 在选定范围内进行精细校准
   - 发送11个trim值进行测试
   - 选择最接近目标频率的trim值

3. **计算编程频率trim**：
   - 使用线性插值计算编程频率的trim值
   - 编程频率固定为22.1184 MHz

**频率校准流程**（STC15）：

1. **第一轮校准**：
   - 发送0x00命令，包含12个trim挑战
   - 根据响应选择合适的分频范围

2. **第二轮校准**：
   - 在选定范围内进行精细校准（±3范围）
   - 选择最佳trim值

**波特率切换**：
```python
# STC15A
program_speed = 22118400
program_trim = calculate_from_calibration(...)
packet = bytes([0x8e])
packet += struct.pack(">H", program_trim)
packet += struct.pack(">B", 230400 // baud_transfer)
packet += bytes([0xa1, 0x64, 0xb8, 0x00, iap_wait, 0x20, 0xff, 0x00])

# STC15
packet = bytes([0x01])
packet += bytes(prog_trim)
packet += struct.pack(">H", int(65536 - program_speed / (baud_transfer * 4)))
packet += bytes(reversed(user_trim))
packet += bytes([iap_wait])
```

**选项字节格式**：
- **STC15A**：13字节
- **STC15**：5字节（部分型号可能更多）

**特殊处理**：
- BSL 7.2+需要5A A5魔术字
- 写入完成后需要发送完成命令（0x07）
- 支持外部时钟源的特殊处理

### 4. STC8系列

**协议类**：`Stc8Protocol`, `Stc8dProtocol`, `Stc8gProtocol`

**特点**：
- 继承STC15协议基础
- 频率校准方式略有不同
- 支持trim分频器
- 选项字节：5字节

**频率校准差异**：

**STC8**：
- 使用分频器（divider）概念
- 第一轮：测试分频器1-5
- 第二轮：在选定分频器下进行精细校准

**STC8d**：
- 校准包格式：`[0x00, 0x08] + 4组trim挑战`
- 第二轮：12个trim值（±6范围）

**STC8g**：
- 校准包格式：`[0x00, 0x05] + 特殊trim挑战`
- 需要epilogue（12字节填充）
- 第二轮也需要epilogue（19字节填充）

**选项字节格式**：
```python
packet = 40 * bytearray([0xff])
packet[3] = 0
packet[6] = 0
packet[22] = 0
packet[24:28] = struct.pack(">I", trim_frequency)
packet[28:30] = trim_value
packet[30] = trim_divider
packet[32] = msr[0]
packet[36:40] = msr[1:5]
```

### 5. STC32系列

**协议类**：使用`Stc8dProtocol`

**特点**：
- 基于STC8d协议
- 支持MCS-251架构
- 需要线性基地址（Intel HEX类型04记录）
- CODE和EEPROM地址空间分离

**特殊处理**：
- CODE起始地址：0xFF0000（MCS-251）
- EEPROM起始地址：0xFE0000
- 需要program_eeprom_split选项

### 6. USB协议（STC15 USB）

**协议类**：`StcUsb15Protocol`

**特点**：
- 使用USB控制传输
- VID: 0x5354, PID: 0x4312
- 块大小：128字节
- 每个7字节数据块单独校验

**USB包格式**：
- 控制传输，每次最多8字节
- 数据以7字节为单位，每7字节后跟1字节校验和
- 校验和：`reduce(lambda x, y: x - y, data, 0) & 0xff`

**关键命令**：
- 0x01：握手
- 0x03：擦除
- 0x05：解锁（wValue=0xa55a）
- 0x22：首块写入
- 0x02：后续块写入
- 0x04：设置选项
- 0xFF：断开

---

## 关键实现细节

### 1. 数据包读写

**读取数据包**：
```python
def read_packet(self):
    # 1. 读取帧起始（0x46 0xB9）
    # 2. 读取方向标志（0x68）
    # 3. 读取长度（2字节，大端序）
    # 4. 读取数据载荷
    # 5. 验证校验和
    # 6. 验证帧结束（0x16）
    # 返回载荷数据
```

**写入数据包**：
```python
def write_packet(self, packet_data):
    # 1. 构建帧起始（0x46 0xB9）
    # 2. 添加方向标志（0x6A）
    # 3. 添加长度（数据长度+开销）
    # 4. 添加数据载荷
    # 5. 计算并添加校验和
    # 6. 添加帧结束（0x16）
    # 7. 发送数据
```

### 2. 错误处理

**常见错误类型**：
- `StcFramingException`：帧格式错误、校验和错误
- `StcProtocolException`：协议错误、命令响应错误
- `SerialTimeoutException`：串口超时

**错误处理策略**：
- 握手阶段：忽略错误，持续重试直到成功
- 数据传输阶段：立即报告错误并退出
- 超时设置：握手阶段0.5秒，数据传输阶段15秒

### 3. 进度显示

**实现方式**：
- 使用tqdm库显示进度条
- 回调函数：`progress_cb(current, written, maximum)`
- 每写入一个块更新一次进度

### 4. Intel HEX文件处理

**支持格式**：
- Intel HEX 8位地址模式
- Intel HEX 16位地址模式（段地址）
- Intel HEX 32位地址模式（线性地址）

**关键处理**：
- 解析HEX记录类型（00/01/02/03/04/05）
- 提取二进制数据
- 处理线性基地址（MCS-251需要）

---

## 移植到STM32的注意事项

### 1. 硬件接口

**串口配置**：
- 支持多种波特率（2400-115200+）
- 支持无校验和偶校验
- 需要精确的波特率控制
- 建议使用DMA进行数据传输

**复位控制**：
- DTR/RTS引脚控制（可选）
- 支持自动复位功能
- 复位时序：拉低250ms，释放30ms

### 2. 协议实现

**数据包处理**：
- 实现数据包解析和构建
- 校验和计算（单字节/双字节）
- 超时处理机制

**状态机设计**：
```
IDLE -> CONNECTING -> HANDSHAKE -> IDENTIFY -> 
HANDSHAKE_BAUD -> ERASE -> PROGRAM -> OPTIONS -> DISCONNECT
```

### 3. 内存管理

**Flash数据缓冲**：
- 需要足够的RAM缓冲（建议至少512字节）
- 支持分块处理大文件
- 考虑使用外部Flash存储待烧录文件

**选项字节存储**：
- 不同型号选项字节长度不同（1-40字节）
- 需要动态分配或使用最大长度缓冲区

### 4. 频率校准（STC15+）

**实现要点**：
- 需要浮点运算支持（或定点数实现）
- 线性插值计算
- 多轮校准流程
- 校准数据存储

**优化建议**：
- 使用查找表替代部分计算
- 简化校准流程（如果不需要精确频率）

### 5. 文件系统

**HEX文件解析**：
- 实现Intel HEX解析器
- 支持多种地址模式
- 二进制文件直接支持

**文件存储**：
- 支持SD卡或外部Flash
- 文件大小限制考虑

### 6. 用户界面

**显示需求**：
- MCU信息显示
- 进度显示
- 错误信息提示
- 选项配置界面

### 7. 性能优化

**优化点**：
- 使用DMA减少CPU占用
- 批量数据处理
- 减少不必要的延时
- 优化校验和计算

### 8. 测试建议

**测试项目**：
- 各型号MCU连接测试
- 不同波特率测试
- 大文件烧录测试
- 错误恢复测试
- 长时间稳定性测试

### 9. 代码结构建议

```
stc_programmer/
├── core/
│   ├── protocol_base.c/h      # 基础协议类
│   ├── protocol_stc89.c/h     # STC89协议
│   ├── protocol_stc12.c/h     # STC12协议
│   ├── protocol_stc15.c/h     # STC15协议
│   ├── protocol_stc8.c/h      # STC8协议
│   └── protocol_usb.c/h       # USB协议
├── utils/
│   ├── packet.c/h              # 数据包处理
│   ├── checksum.c/h            # 校验和计算
│   ├── ihex.c/h                # HEX文件解析
│   └── model_db.c/h            # 型号数据库
├── hal/
│   ├── uart.c/h                # UART驱动
│   ├── usb.c/h                 # USB驱动
│   └── reset.c/h               # 复位控制
└── app/
    ├── main.c                  # 主程序
    └── ui.c/h                  # 用户界面
```

### 10. 关键参数配置

**可配置参数**：
- 握手波特率（默认2400）
- 传输波特率（默认115200）
- 超时时间
- 块大小
- 自动复位使能

---

## 总结

STC烧录工具的核心是理解不同型号MCU的协议差异，特别是：

1. **数据包格式**：校验和方式、数据包结构
2. **握手流程**：同步方式、波特率切换
3. **频率校准**：STC15+系列需要复杂的校准流程
4. **选项字节**：不同型号格式和长度不同
5. **命令码**：不同型号使用不同的命令码

移植到STM32时，需要重点关注：
- 精确的时序控制
- 多协议支持
- 内存管理
- 错误处理
- 用户界面

建议采用模块化设计，将协议实现与硬件抽象层分离，便于维护和扩展。

---

## 参考资料

- stcgal源码：https://github.com/grigorig/stcgal
- STC官方ISP工具（参考协议实现）
- STC各系列数据手册

---

**文档版本**：v1.0  
**最后更新**：2024年  
**作者**：基于stcgal源码分析

